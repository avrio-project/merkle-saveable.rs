var N=null,E="",T="t",U="u",searchIndex={};
var R=["algorithm","root_hash","option","proof","usize","result","to_owned","clone_into","try_from","try_into","borrow_mut","into_iter","type_id","merkletree","ordering","partial_cmp","formatter","MerkleTree","Hashable","LeavesIntoIterator","LeavesIterator"];

searchIndex["merkle"]={"doc":"merkle implements a Merkle Tree in Rust.","i":[[3,R[17],"merkle","A Merkle tree is a binary tree, with values of type `T` at…",N,N],[12,R[0],E,"The hashing algorithm used by this Merkle tree",0,N],[3,"Proof",E,"An inclusion proof represent the fact that a `value` is a…",N,N],[12,R[0],E,"The hashing algorithm used in the original `MerkleTree`",1,N],[12,R[1],E,"The hash of the root of the original `MerkleTree`",1,N],[12,"lemma",E,"The first `Lemma` of the `Proof`",1,N],[12,"value",E,"The value concerned by this `Proof`",1,N],[3,R[19],E,"An iterator over the leaves of a `Tree`.",N,N],[3,R[20],E,"An borrowing iterator over the leaves of a `Tree`. Adapted…",N,N],[11,"from_vec",E,"Constructs a Merkle Tree from a vector of data blocks.…",0,[[[R[0]],["vec"]],["self"]]],[11,R[1],E,"Returns the root hash of Merkle tree",0,[[["self"]],["vec"]]],[11,"height",E,"Returns the height of Merkle tree",0,[[["self"]],[R[4]]]],[11,"count",E,"Returns the number of leaves in the Merkle tree",0,[[["self"]],[R[4]]]],[11,"is_empty",E,"Returns whether the Merkle tree is empty or not",0,[[["self"]],["bool"]]],[11,"gen_proof",E,"Generate an inclusion proof for the given value. Returns…",0,[[["self"],[T]],[[R[3]],[R[2],[R[3]]]]]],[11,"gen_nth_proof",E,"Generate an inclusion proof for the `n`-th leaf value.",0,[[["self"],[R[4]]],[[R[3]],[R[2],[R[3]]]]]],[11,"iter",E,"Creates an `Iterator` over the values contained in this…",0,[[["self"]],["leavesiterator"]]],[11,"new",E,"Constructs a new `Proof`",1,[[[T],[R[0]],["vec",["u8"]],["lemma"],["u8"]],["self"]]],[11,"validate",E,"Checks whether this inclusion proof is well-formed, and…",1,[[["self"]],["bool"]]],[11,"index",E,"Returns the index of this proof's value, given the total…",1,[[["self"],[R[4]]],[R[4]]]],[8,R[18],E,"The type of values stored in a `MerkleTree` must implement…",N,N],[10,"update_context",E,"Update the given `context` with `self`.",2,[[["self"],["context"]]]],[11,R[6],E,E,0,[[["self"]],[T]]],[11,R[7],E,E,0,[[[T],["self"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[11],E,E,0,[[],["i"]]],[11,"into",E,E,0,[[],[U]]],[11,R[8],E,E,0,[[[U]],[R[5]]]],[11,R[9],E,E,0,[[],[R[5]]]],[11,R[10],E,E,0,[[["self"]],[T]]],[11,"borrow",E,E,0,[[["self"]],[T]]],[11,R[12],E,E,0,[[["self"]],["typeid"]]],[11,R[6],E,E,1,[[["self"]],[T]]],[11,R[7],E,E,1,[[[T],["self"]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,"into",E,E,1,[[],[U]]],[11,R[8],E,E,1,[[[U]],[R[5]]]],[11,R[9],E,E,1,[[],[R[5]]]],[11,R[10],E,E,1,[[["self"]],[T]]],[11,"borrow",E,E,1,[[["self"]],[T]]],[11,R[12],E,E,1,[[["self"]],["typeid"]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[11],E,E,3,[[],["i"]]],[11,"into",E,E,3,[[],[U]]],[11,R[8],E,E,3,[[[U]],[R[5]]]],[11,R[9],E,E,3,[[],[R[5]]]],[11,R[10],E,E,3,[[["self"]],[T]]],[11,"borrow",E,E,3,[[["self"]],[T]]],[11,R[12],E,E,3,[[["self"]],["typeid"]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[11],E,E,4,[[],["i"]]],[11,"into",E,E,4,[[],[U]]],[11,R[8],E,E,4,[[[U]],[R[5]]]],[11,R[9],E,E,4,[[],[R[5]]]],[11,R[10],E,E,4,[[["self"]],[T]]],[11,"borrow",E,E,4,[[["self"]],[T]]],[11,R[12],E,E,4,[[["self"]],["typeid"]]],[11,"next",E,E,4,[[["self"]],[[T],[R[2]]]]],[11,"next",E,E,3,[[["self"]],[R[2]]]],[11,"eq",E,E,0,[[["self"],[R[13]]],["bool"]]],[11,"eq",E,E,1,[[[R[3]],["self"]],["bool"]]],[11,"clone",E,E,0,[[["self"]],[R[13]]]],[11,"clone",E,E,1,[[["self"]],[R[3]]]],[11,"cmp",E,E,0,[[["self"],[R[13]]],[R[14]]]],[11,"cmp",E,E,1,[[[R[3]],["self"]],[R[14]]]],[11,R[11],E,"Creates a consuming iterator, that is, one that moves each…",0,[[]]],[11,R[15],E,E,0,[[["self"],[R[13]]],[[R[2],[R[14]]],[R[14]]]]],[11,R[15],E,E,1,[[[R[3]],["self"]],[[R[2],[R[14]]],[R[14]]]]],[11,"fmt",E,E,0,[[["self"],[R[16]]],[R[5]]]],[11,"fmt",E,E,1,[[["self"],[R[16]]],[R[5]]]],[11,"hash",E,E,0,[[["self"],["h"]]]],[11,"hash",E,E,1,[[["self"],["h"]]]]],"p":[[3,R[17]],[3,"Proof"],[8,R[18]],[3,R[19]],[3,R[20]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);